#' Generate Planning Matrix for Multi-factor ANOVA
#'
#' This function generates a planning matrix used in the context of multi-factor ANOVA experimental design.
#' It creates a matrix based on the number of factors (k) and the order of entries. The matrix includes
#' all combinations of factor levels and their interactions.
#'
#' @param k An integer indicating the number of factors in the ANOVA design.
#' @param plus_first Logical; if TRUE, positive entries precede negative ones in the planning matrix.
#'                   If FALSE, the order is reversed. Normally, in STAT 404, this should be FALSE.
#'                   However, in other works it is normally TRUE.
#' @return A data frame representing the planning matrix, with columns for each factor and their interactions.
#'         The columns are named using uppercase letters starting from 'A'.
#' @examples
#' # Generate a planning matrix for 3 factors with positive entries first
#' generate_planning_matrix(3, plus_first = TRUE)
#'
#' # Generate a planning matrix for 4 factors with negative entries first
#' generate_planning_matrix(4, plus_first = FALSE)
#' @export
generate_planning_matrix <- function(k, plus_first = TRUE){
  # check inputs
  if (!is.numeric(k) || length(k) != 1 || k != as.integer(k) || k <= 0) {
    stop("'k' must be a single positive integer.")
  }
  if (!is.logical(plus_first) || length(plus_first) != 1) {
    stop("'plus_first' must be a single logical value.")
  }
  # determine if we put positive or negative first
  if (plus_first){  entry_1 <- 1 ; entry_2 <- -1 }
  else{ entry_1 <- -1 ; entry_2 <- 1 }
  # figure out the number of experimental runs
  runs <- 2^k
  # figure out the number of repitions required for each string combination
  reps = (runs / 2^(1:k))
  # declare empty matrix
  plan_mat <- matrix(0, ncol = k, nrow = runs)
  # for every repition
  for (r in 1:length(reps)){
    # repeat 1 and -1 the requirex amount of times (see: reps)
    str_r <- rep(c(rep(entry_1, times = reps[r]), rep(entry_2, times = reps[r])))
    # then, repeat this pattern so that there are 2^k in each column
    plan_mat[, r] = rep(str_r, times = rev(reps)[r])
  }
  # map planning matrix to data frame
  plan_mat <- data.frame(plan_mat)
  # determine the factor names (from alphabet)
  factor_names = toupper(letters[1:k])
  colnames(plan_mat) = factor_names
  # for every factor combination length (AB, ABC, ABCD, ...)
  for (i in 2:k){
    # determine the string combinations at this level
    combos <- (combn(factor_names, i, simplify = FALSE))
    # for every subset of those combos (AB, AC, AD, ... )
    for (comb in combos){
      # append the column-wise products to the dataframe
      plan_mat[, paste(comb, collapse = "")] <-  apply(plan_mat[, comb], 1, prod)
    }
  }
  # return the planning matrix
  return(plan_mat)
}

#' Generate Interaction Plot for Two Factors
#'
#' This function creates an interaction plot for two factors using ggplot2. It's useful in
#' analyzing the interactions between two factors in a multi-factor ANOVA design. The function
#' relies on \code{\link{generate_planning_matrix}} to determine the factor levels.
#'
#' @param int1 The name of the first factor for the interaction plot, corresponding to
#'        column names in the matrix generated by \code{\link{generate_planning_matrix}}
#'        (e.g., "A", "B", "C").
#' @param int2 The name of the second factor for the interaction plot, similar to int1.
#' @param df A data frame containing the data for the ANOVA analysis.
#' @return A ggplot object representing the interaction plot between the two specified factors.
#' @import ggplot2
#' @seealso \code{\link{generate_planning_matrix}}
#' @note The factors int1 and int2 should be named according to the columns generated
#'       by \code{\link{generate_planning_matrix}}, typically "A", "B", "C", etc.
#' @examples
#' # Create dummy data for demonstration
#' set.seed(404) # for reproducibility
#' dummy_df <- data.frame(A = rnorm(8), B = rnorm(8), C = rnorm(8), D = rnorm(8))
#'
#' # Generate an interaction plot between factors A and B using dummy data
#' generate_interaction_plot("A", "B", dummy_df)
#' @export
generate_interaction_plot <- function(int1, int2, df){
  # input validation
  if (!is.character(int1) || length(int1) != 1) {
    stop("'int1' must be a single character string.")
  }
  if (!is.character(int2) || length(int2) != 1) {
    stop("'int2' must be a single character string.")
  }
  if (!is.data.frame(df)) {
    stop("'df' must be a data frame.")
  }
  # create a new in-function dataframe from the size of the input df
  newdf <- cbind(generate_planning_matrix(
    log(nrow(df), base=2), FALSE),
    meanCol <- rowMeans(df))
  # create a new plotting dataframe
  plotDF <- data.frame(
    # low level and high level (repeated twice)
    x = rep(c(-1, 1), 2),
    # different mean responses for levels of int1 and int2
    y = c(mean(newdf$meanCol[newdf[, int1]==-1 & newdf[, int2] == -1]),
          mean(newdf$meanCol[newdf[, int1]==-1 & newdf[, int2] == 1]),
          mean(newdf$meanCol[newdf[, int1]==1 & newdf[, int2] == -1]),
          mean(newdf$meanCol[newdf[, int1]==1 & newdf[, int2] == 1])),
    # groups of lines (for plotting)
    lineGroup = rep(1:2, each = 2),
    # labels for corners of lines
    label = c(paste(int1, "= -1 &", int2, "= -1"),
              paste(int1, "= -1 &", int2, "= 1"),
              paste(int1, "= 1 &", int2, "= -1"),
              paste(int1, "= 1 &", int2, "= 1"))
  )
  # create plot
  g <- ggplot(data = plotDF, aes(x = x, y = y, group = lineGroup)) +
    geom_line() +
    geom_text(aes(label = label), hjust = 1.05, vjust = 0.05, check_overlap = TRUE)+
    xlim(-1.75, 1.75) + theme_bw() +
    labs(title = paste("Interaction Plot Between", int1, "and", int2),
         subtitle = paste("Change in Response with Changing Level of", int2, "Conditioned on", int1),
         x = paste("Level of", int2), y = "Response Variable")+
    ylim(-1, max(plotDF$y) + 0.5)
  # return plot
  return(g)
}
