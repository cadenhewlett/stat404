#' Generate Planning Matrix for Multi-factor ANOVA
#'
#' This function generates a planning matrix used in the context of multi-factor ANOVA experimental design.
#' It creates a matrix based on the number of factors (k) and the order of entries. The matrix includes
#' all combinations of factor levels and their interactions.
#'
#' @param k An integer indicating the number of factors in the ANOVA design.
#' @param plus_first Logical; if TRUE, positive entries precede negative ones in the planning matrix.
#'                   If FALSE, the order is reversed. Normally, in STAT 404, this should be FALSE.
#'                   However, in other works it is normally TRUE.
#' @return A data frame representing the planning matrix, with columns for each factor and their interactions.
#'         The columns are named using uppercase letters starting from 'A'.
#' @examples
#' # Generate a planning matrix for 3 factors with positive entries first
#' generate_planning_matrix(3, plus_first = TRUE)
#'
#' # Generate a planning matrix for 4 factors with negative entries first
#' generate_planning_matrix(4, plus_first = FALSE)
#' @export
generate_planning_matrix <- function(k, plus_first = TRUE){
  # check inputs
  if (!is.numeric(k) || length(k) != 1 || k != as.integer(k) || k <= 0) {
    stop("'k' must be a single positive integer.")
  }
  if (!is.logical(plus_first) || length(plus_first) != 1) {
    stop("'plus_first' must be a single logical value.")
  }
  # determine if we put positive or negative first
  if (plus_first){  entry_1 <- 1 ; entry_2 <- -1 }
  else{ entry_1 <- -1 ; entry_2 <- 1 }
  # figure out the number of experimental runs
  runs <- 2^k
  # figure out the number of repitions required for each string combination
  reps = (runs / 2^(1:k))
  # declare empty matrix
  plan_mat <- matrix(0, ncol = k, nrow = runs)
  # for every repition
  for (r in 1:length(reps)){
    # repeat 1 and -1 the requirex amount of times (see: reps)
    str_r <- rep(c(rep(entry_1, times = reps[r]), rep(entry_2, times = reps[r])))
    # then, repeat this pattern so that there are 2^k in each column
    plan_mat[, r] = rep(str_r, times = rev(reps)[r])
  }
  # map planning matrix to data frame
  plan_mat <- data.frame(plan_mat)
  # determine the factor names (from alphabet)
  factor_names = toupper(letters[1:k])
  colnames(plan_mat) = factor_names
  # for every factor combination length (AB, ABC, ABCD, ...)
  for (i in 2:k){
    # determine the string combinations at this level
    combos <- (combn(factor_names, i, simplify = FALSE))
    # for every subset of those combos (AB, AC, AD, ... )
    for (comb in combos){
      # append the column-wise products to the dataframe
      plan_mat[, paste(comb, collapse = "")] <-  apply(plan_mat[, comb], 1, prod)
    }
  }
  # return the planning matrix
  return(plan_mat)
}

#' Generate Interaction Plot for Two Factors
#'
#' This function creates an interaction plot for two factors using ggplot2. It's useful in
#' analyzing the interactions between two factors in a multi-factor ANOVA design. The function
#' relies on \code{\link{generate_planning_matrix}} to determine the factor levels.
#'
#' @param int1 The name of the first factor for the interaction plot, corresponding to
#'        column names in the matrix generated by \code{\link{generate_planning_matrix}}
#'        (e.g., "A", "B", "C").
#' @param int2 The name of the second factor for the interaction plot, similar to int1.
#' @param df A data frame containing the data for the ANOVA analysis.
#' @return A ggplot object representing the interaction plot between the two specified factors.
#' @import ggplot2
#' @seealso \code{\link{generate_planning_matrix}}
#' @note The factors int1 and int2 should be named according to the columns generated
#'       by \code{\link{generate_planning_matrix}}, typically "A", "B", "C", etc.
#' @examples
#' # Create dummy data for demonstration
#' set.seed(404) # for reproducibility
#' dummy_df <- data.frame(A = rnorm(8), B = rnorm(8), C = rnorm(8), D = rnorm(8))
#'
#' # Generate an interaction plot between factors A and B using dummy data
#' generate_interaction_plot("A", "B", dummy_df)
#' @export
generate_interaction_plot <- function(int1, int2, df){
  # input validation
  if (!is.character(int1) || length(int1) != 1) {
    stop("'int1' must be a single character string.")
  }
  if (!is.character(int2) || length(int2) != 1) {
    stop("'int2' must be a single character string.")
  }
  if (!is.data.frame(df)) {
    stop("'df' must be a data frame.")
  }
  # create a new in-function dataframe from the size of the input df
  newdf <- cbind(generate_planning_matrix(
    log(nrow(df), base=2), FALSE),
    meanCol <- rowMeans(df))
  # create a new plotting dataframe
  plotDF <- data.frame(
    # low level and high level (repeated twice)
    x = rep(c(-1, 1), 2),
    # different mean responses for levels of int1 and int2
    y = c(mean(newdf$meanCol[newdf[, int1]==-1 & newdf[, int2] == -1]),
          mean(newdf$meanCol[newdf[, int1]==-1 & newdf[, int2] == 1]),
          mean(newdf$meanCol[newdf[, int1]==1 & newdf[, int2] == -1]),
          mean(newdf$meanCol[newdf[, int1]==1 & newdf[, int2] == 1])),
    # groups of lines (for plotting)
    lineGroup = rep(1:2, each = 2),
    # labels for corners of lines
    label = c(paste(int1, "= -1 &", int2, "= -1"),
              paste(int1, "= -1 &", int2, "= 1"),
              paste(int1, "= 1 &", int2, "= -1"),
              paste(int1, "= 1 &", int2, "= 1"))
  )
  # create plot
  g <- ggplot(data = plotDF, aes(x = x, y = y, group = lineGroup)) +
    geom_line() +
    geom_text(aes(label = label), hjust = 1.05, vjust = 0.05, check_overlap = TRUE)+
    xlim(-1.75, 1.75) + theme_bw() +
    labs(title = paste("Interaction Plot Between", int1, "and", int2),
         subtitle = paste("Change in Response with Changing Level of", int2, "Conditioned on", int1),
         x = paste("Level of", int2), y = "Response Variable")+
    ylim(-1, max(plotDF$y) + 0.5)
  # return plot
  return(g)
}

#' Generate Normal or Half-Normal Plot of Estimated Effects
#'
#' This function generates a normal or half-normal plot of estimated effects based on input data.
#' It's useful for analyzing the effects in a multi-factor ANOVA design. The function computes
#' estimated effects using a planning matrix, which is generated by the
#' \code{\link{generate_planning_matrix}} function, and compares them against the theoretical
#' quantiles of the standard normal distribution.
#'
#' @param y Numeric vector representing the input data for which the estimated effects are to be plotted.
#'        The length of `y` must be a power of 2, aligning with the factorial design in ANOVA.
#' @param half_normal Logical; if TRUE, creates a half-normal plot, otherwise, a normal plot is generated.
#' @param plus Logical; if TRUE, uses positive-first ordering in generating the planning matrix.
#'        This parameter is passed to \code{\link{generate_planning_matrix}}.
#' @return A ggplot object representing the normal or half-normal plot of estimated effects.
#' @import ggplot2
#' @seealso \code{\link{generate_planning_matrix}} for the function used to generate the planning matrix.
#' @examples
#' # Create dummy data
#' set.seed(404)
#' dummy_y <- rnorm(2^4)
#'
#' # Generate a normal plot
#' generate_normal_plot(dummy_y)
#'
#' # Generate a half-normal plot
#' generate_normal_plot(dummy_y, half_normal = TRUE)
#' @export
generate_normal_plot <- function(y, half_normal = FALSE, plus = FALSE){
  # Input validation
  if (!is.numeric(y)) {
    stop("'y' must be a numeric vector.")
  }
  if (length(y) != 2^floor(log(length(y), base = 2))) {
    stop("'y' must have a length that is a power of 2. This is required for full factorial with high/low treatments, since n = 2^k.")
  }
  if (!is.logical(half_normal) || length(half_normal) != 1) {
    stop("'half_normal' must be a single logical value.")
  }
  if (!is.logical(plus) || length(plus) != 1) {
    stop("'plus' must be a single logical value.")
  }
  # determine the number of treatments by log base 2 the sample size
  k = log(length(y), base = 2)
  # generate a k-factor planning matrix
  plan_mat = generate_planning_matrix(k, plus_first = FALSE)
  # extract the names
  combos <- colnames(plan_mat)
  # add the input values  to the matrix
  plan_mat[, "Values"] = y
  # and assign it to a new variable
  dfp = plan_mat
  # generate the mu hat estimates for the data
  estimates <- data.frame(combos, mu_hat = unlist(lapply(combos,
       function(c) { mean(dfp$Values[dfp[, c] == 1] - dfp$Values[dfp[, c] == -1])})))

  # define the plotting vertical limit
  y_bound = round(max(abs(min(estimates$mu_hat)),  max(estimates$mu_hat)), 1)

  # make decisions based on normal or half-normal
  if(half_normal){
    # take the absolute value of the mu-hat values
    estimates$mu_hat = abs(estimates$mu_hat)
    # derive the slightly different percentages for quantiles
    p = 0.5 + 0.5*(1:nrow(estimates)-0.5) / nrow(estimates)

    # vertical plotting area
    vplot = c(0, y_bound)

    # add extra info to the labels and title
    extLab = "Absolue"
    extTitle = "Half-"

    # use a pink/maroon colour
    textcol = "#380d11"
    fillcol = "#fab9cd"
    outlinecol = "#80324a"
  }
  else {
    # generate the theoretical quantiles of the normal distribution to compare against
    p = (1:nrow(estimates)-0.5) / nrow(estimates)

    # vertical plotting area goes both directions now
    vplot = c(-y_bound, y_bound)

    # no extra info needed on plot labels
    extLab = ""
    extTitle = ""

    # use a blue/turquoise color
    textcol = "#0d3835"
    fillcol = "#baf7f3"
    outlinecol = "#026e67"
  }

  # define the plotting vertical limit
  y_bound = round(max(abs(min(estimates$mu_hat)),  max(estimates$mu_hat)), 1)

  # make a plotting data frame
  gg_df <- data.frame(
    # N(0,1) quantiles
    x = qnorm(p),
    # Estimates
    mu_hat = estimates$mu_hat[order(estimates$mu_hat)],
    # Names
    combos = estimates$combos[order(estimates$mu_hat)]
  )
  # create the plot
  g <- ggplot(gg_df, aes(x, mu_hat)) +
    # add points with changing col
    geom_point(size = 3.5, shape = 21,
               fill = fillcol,
               color = outlinecol) +
    # align text with points
    geom_text(aes(label = combos),
              hjust = 0.5,
              vjust = -1.15,
              size = 3,
              color = textcol) +
    # set vertical plot lims
    ylim(vplot) +
    # add dynamic titles
    labs(x = paste(extLab, "Quantiles of Standard Normal Distribution"),
         y = paste(extLab, "Estimated Effects"),
         title = paste(extTitle, "Normal Plot of the Estimated Effects", sep = "")) +
    theme_bw() +
    scale_x_continuous(minor_breaks = seq(-3, 3, by = 0.25)) +
    theme(panel.grid.minor = element_line(color = "grey60", linewidth = 0.2, linetype = "dotted"))
  return(g)
}


#' Full Factorial Design ANOVA
#'
#' This function performs a full factorial design ANOVA on experimental data with a high/low design.
#'
#' @param df A data frame representing a full factorial experimental design. Each column represents a factor with
#' two levels (-1 and 1), and each row represents an experimental run.
#' @param alpha The significance level (alpha) used for hypothesis testing. The default value is 0.05.
#' @param plus_first Logical; if TRUE, uses positive-first ordering in generating the planning matrix for the ANOVA analysis.
#'        This parameter is passed to \code{\link{generate_planning_matrix}}.
#' @return A data frame representing the ANOVA table with columns for source, degrees of freedom (DF), sum of squares (SS),
#' mean sum of squares (MSS), F-statistics (F), p-values (P), and a significance indicator (signif) for each source.
#' The table includes sources for each combination of factor levels, error, and total.
#' @seealso \code{\link{generate_planning_matrix}} for the function used to generate the planning matrix.
#' @examples
#' # Create a data frame with response data for two factors
#' data <- data.frame(
#'   High = c(30, 40, 35, 45, 38, 50, 23, 28),
#'   Low = c(20, 25, 22, 30, 28, 35, 20, 25)
#' )
#' # Perform a full factorial ANOVA
#' full_factorial(data)
#'
#' @export
full_factorial <- function(df, alpha = 0.05, plus_first = FALSE) {
  # Input validation: Check if df is a data frame with at least two columns
  if (!is.data.frame(df) || ncol(df) < 2) {
    stop("The input 'df' should be a data frame with at least two columns representing experimental runs at high and low treatment levels.")
  }

  # Check if the two response columns are equal-length
  if (nrow(df) > 0 && length(df[[1]]) != length(df[[2]])) {
    stop("The two response columns in 'df' must have the same length.")
  }
  # normally this is 2 or 1
  n = ncol(df)
  # find the number of treatments from input data size
  k = log(nrow(df), base = 2) # 2^k groups, rearranged
  # generate planning matrix with our function
  plan_mat = generate_planning_matrix(k, plus_first = plus_first)
  # store combination names
  combos <- colnames(plan_mat)
  # append row-wise means of df
  plan_mat[, "Means"] = rowMeans(df)
  # store in new variable
  dfp = plan_mat
  # generate the estimates
  estimates <- data.frame(combos, mu_hat = unlist(lapply(combos,
                                                         function(c) { mean(dfp$Means[dfp[, c] == 1] - dfp$Means[dfp[, c] == -1])})))
  # find the sum of squares
  estimates$ssq <- (n*(2^(k-2)))*(estimates$mu_hat)^2
  # find grand mean (for estimation)
  eta_hat = mean(unlist(df))
  # make empty matrix for predictions
  preds <- matrix(0, 2^k, 1)
  # make a planning matrix again, to restore order of signs
  signs <- generate_planning_matrix(k, FALSE)

  # generate all predictions (same as y_{i.} but whatevs)
  for (i in 1:nrow(signs)){
    preds[i] = eta_hat + sum(0.5*(as.numeric(signs[i, ]) * estimates$mu_hat))
  }

  # create empty matrix for residuals
  r = matrix(0, 2^k, n)
  # create empty matrix for sum of squares tot
  s = matrix(0, 2^k, n)
  # for every row
  for (i in 1:(2^k)){
    # and every column
    for (j in 1:n){
      # compute the (i,j) residual
      r[i,j] =  df[i,j] - preds[i]
      # compute the (i,j) sum of squares
      s[i,j] = df[i,j] - eta_hat
    }
  }
  # then sserr is RSS
  sserr = sum(r^2)
  # then sstot is sum of squared differences
  sstot = sum(s^2)
  # then our estimates sum of squares + RSS should be total
  sstot == (sum(estimates$ssq) + sserr)
  # the we find the degrees of freedom
  dfs <- c(rep(1, times = length(combos)))
  # and the per-df sum of squares
  mss_vals <- estimates$ssq/dfs
  msserr <- sserr / ((2^k) * (n - 1))
  # and compute the f-stats
  f_vals <- mss_vals / msserr
  # finally, construct the anova table
  anovatbl <- data.frame(
    Source = c(combos, "Error", "Total"),
    DF = c(dfs, (2^k) * (n - 1), (n * 2^k)-1),
    SS = round(c(estimates$ssq, sserr, sstot), 2),
    MSS = round(c(mss_vals, msserr, NA), 3),
    F = c(round(f_vals, 2), NA, NA),
    P = c(signif(pf(f_vals, 1, (2^k) * (n - 1), lower.tail = FALSE), 3), NA, NA)
  )
  anovatbl <- cbind(anovatbl, signif = anovatbl$P < alpha)
  return(anovatbl)
}
